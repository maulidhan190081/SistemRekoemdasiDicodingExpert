# -*- coding: utf-8 -*-
"""Sistem Rekomendasi Dicoding Expert

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-q-AA00pTZJJczrv3lxD1JkpJh5a7dnP

# Proyek Sistem Rekomendasi: [Input Nama Dataset]
- **Nama:** [Maulidhan Ady Nugraha]
- **Email:** [maulidhan6@gmail.com]
- **Username Dicoding:** [maulidhanadynugraha]

## Import Semua Packages/Library

mengimport semua library yang dibutuhkan
"""

import os
import pandas as pd
import kagglehub
import numpy as np
import zipfile
import json

from sklearn.decomposition import TruncatedSVD
from sklearn.metrics.pairwise import cosine_similarity

"""## Data Preparation

### Data Loading

load data dari kaglle link sebagai berikut [data_netflix](https://www.kaggle.com/datasets/rishitjavia/netflix-movie-rating-dataset)
"""

# Download latest version
path = kagglehub.dataset_download("rishitjavia/netflix-movie-rating-dataset")

print("Path to dataset files:", path)

"""membaca data yang telah diload"""

# Get the list of files in the downloaded directory
files = os.listdir(path)

# Print the list of files
path_list_film=files[0]
path_list_rating = files[1]

# Construct the full path to the CSV file
file_path_list_rating = os.path.join(path, path_list_rating)
file_path_list_film = os.path.join(path, path_list_film)

"""membuat dataframe dari data rating film netflix"""

# Read the CSV file
df = pd.read_csv(file_path_list_rating)

"""#### Cek Informasi Data

menampilkan data
"""

df

"""mengecek apakah ada data yang kosong"""

df.isnull().sum()

"""melihat berapa user yang ada"""

pd.Series(df["User_ID"].unique()).sort_values() #Convert to pandas Series then sort

"""#### Seleksi User

meneyeleksi user yang sudah merating lebih dari 400 film
"""

user_rating_counts = df.groupby('User_ID')['Rating'].count()
users = user_rating_counts[user_rating_counts >= 400]
users

"""membuat data frame dari user yang sudah diseleksi"""

selected_df = df[df['User_ID'].isin(users.index)]
selected_df

"""menegcek jumlah user setelah proses seleksi"""

pd.Series(selected_df["User_ID"].unique()).sort_values() #Convert to pandas Series then sort

"""melihat jumlah film"""

pd.Series(selected_df["Movie_ID"].unique()).sort_values() #Convert to pandas Series then sort

"""#### Sparsity

Persentase sparsity yang menjadi masalah dalam sistem rekomendasi
"""

maksimum_jumlah_rating = len(selected_df["User_ID"].unique()) * len(selected_df["Movie_ID"].unique())
missing_value=maksimum_jumlah_rating-selected_df["Rating"].count()
sparsity=missing_value/maksimum_jumlah_rating*100

print("Maksimum jumlah rating:",maksimum_jumlah_rating)
print("Jumlah rating:",selected_df["Rating"].count())
print("Jumlah data yang kosong:",missing_value)
print("Sparsity:",round(sparsity, 2),"%")

"""### Data Preprocessing

#### Split Dataset

Melakukan split data 80% training, 20% testing
"""

from sklearn.model_selection import train_test_split
# Split data (80% training, 20% testing)
train_data, test_data = train_test_split(selected_df, test_size=0.2, random_state=42)

print("Training Data:\n", train_data)
print("\nTesting Data:\n", test_data)

"""## Modelling

membuat matriks dari data training
"""

# Membuat matriks pengguna-item
matrix = train_data.pivot_table(index='User_ID', columns='Movie_ID', values='Rating', fill_value=0)

"""menampilkan matriks data training"""

matrix

"""menyeleksi hanya nilai rating saja yang digunakan"""

R= matrix.values

"""menampilkan matrikx nilai rating"""

R

"""#### SVD

melakukan svd dengan menggunakan n_components=50
"""

# Truncated SVD
svd = TruncatedSVD(n_components=50)  # 2 komponen laten

"""Menghitung matriks U (merepresentasikan laten user)"""

U = svd.fit_transform(R)

"""Menghitung matriks Vt"""

# Matriks V^T tereduksi
Vt = svd.components_

"""menampilkan ukuran matriks U"""

U.shape

"""Menampilkan ukuran matriks Vt"""

Vt.shape

"""Mengkalikan matrik U dengan matriks Vt"""

R_pred = np.dot(U, Vt)

# Menampilkan matriks rating yang diprediksi
print("Matriks rating yang diprediksi:")
print(R_pred)

"""#### UB

mencari user similarity dari matrik U
"""

# Menghitung similarity antar pengguna menggunakan cosine similarity
user_similarity = cosine_similarity(U)

# Menampilkan similarity antar pengguna
print("User-User Similarity Matrix:")
print(user_similarity)

"""menampilkan ukuran matriks user similarity"""

user_similarity.shape

"""Menyimpan matriks"""

# Menyimpan ke file .npy
np.save("U.npy", U)
np.save("Vt.npy", Vt)
np.save("R_pred.npy", R_pred)
np.save("user_similarity.npy", user_similarity)

"""Membuat sebuah rekomendasi"""

# Fungsi untuk memberikan rekomendasi berdasarkan pengguna yang mirip
def get_recommendations(user_idx, user_similarity, R_pred, top_n=10):
    # Mendapatkan similarity pengguna dengan pengguna lainnya
    similar_users = user_similarity[user_idx]

    # Menghitung weighted average untuk prediksi rating berdasarkan pengguna yang mirip
    weighted_ratings = np.dot(similar_users, R_pred) / np.sum(np.abs(similar_users))

    # Mengambil top-n rekomendasi untuk pengguna
    recommended_items = np.argsort(weighted_ratings)[::-1][:top_n]

    return recommended_items, weighted_ratings[recommended_items]

"""Menghitung NDCG"""

# Fungsi untuk menghitung DCG dan NDCG
def dcg_at_k(ranking, k):
    """
    Menghitung DCG pada posisi k untuk sebuah ranking.
    ranking: array yang berisi relevansi (rating aktual) item yang direkomendasikan.
    k: jumlah top item yang digunakan.
    """
    ranking = ranking[:k]
    dcg = np.sum(ranking / np.log2(np.arange(2, k + 2)))
    return dcg

def ndcg_at_k(ranking, ideal_ranking, k):
    """
    Menghitung NDCG pada posisi k dengan membandingkan ranking yang diperoleh dan ranking ideal.
    ranking: array yang berisi relevansi (rating aktual) item yang direkomendasikan.
    ideal_ranking: array yang berisi rating aktual item yang diurutkan berdasarkan relevansi tertinggi.
    k: jumlah top item yang digunakan.
    """
    dcg = dcg_at_k(ranking, k)
    idcg = dcg_at_k(ideal_ranking, k)
    return dcg / idcg if idcg > 0 else 0

"""Meinisiasi recomendation dan ndcg dengan mengambil top 10"""

# Menghitung rekomendasi dan NDCG untuk semua pengguna
top_n = 10  # Mengambil 10 rekomendasi teratas
recommendations = {}
ndcg_scores = {}

"""Menjalankan fungsi rekomendasi dan NDCG"""

for user_idx in range(R.shape[0]):  # Iterasi untuk setiap pengguna
    recommended_items, predicted_ratings = get_recommendations(user_idx, user_similarity, R_pred, top_n)

    # Rating aktual untuk item yang direkomendasikan (dari R asli)
    actual_ratings = R[user_idx, recommended_items]

    # Ideal ranking adalah rating yang terurut secara menurun
    ideal_ranking = np.sort(actual_ratings)[::-1]

    # Menghitung NDCG untuk pengguna tersebut
    ndcg_score = ndcg_at_k(actual_ratings, ideal_ranking, top_n)

    # Simpan rekomendasi dan NDCG untuk pengguna
    recommendations[user_idx] = {
        "recommended_items": recommended_items.tolist(),
        "predicted_ratings": predicted_ratings.tolist()
    }
    ndcg_scores[user_idx] = ndcg_score

"""Menyimpan file"""

# Menyimpan ke file .npy
np.save("recommendations.npy", recommendations)
np.save("ndcg_scores.npy", ndcg_scores)

"""### UB Tanpa SVD

Menghitung similarity tanpa SVD
"""

# Menghitung cosine similarity antar pengguna
user_similarity = cosine_similarity(matrix)
user_similarity_df = pd.DataFrame(user_similarity, index=matrix.index, columns=matrix.index)

"""Fungsi Prediksi"""

# Fungsi untuk menghitung prediksi rating
def predict_ratings_all_users(matrix, user_similarity_df):
    recommendations = {}
    for user in matrix.index:
        user_ratings = matrix.loc[user]
        sim_scores = user_similarity_df.loc[user]

        # Hanya hitung untuk film yang belum diberi rating
        unrated_films = user_ratings[user_ratings == 0].index
        predicted_ratings = {}

        for film in unrated_films:
            # Ambil rating semua pengguna untuk film ini
            film_ratings = matrix[film]
            numerator = np.dot(sim_scores, film_ratings)
            denominator = np.abs(sim_scores).sum()
            predicted_ratings[film] = numerator / denominator if denominator != 0 else 0

        recommendations[user] = predicted_ratings
    return recommendations

"""Fungsi untuk menghitung NDCG"""

# Fungsi untuk menghitung NDCG@top_n
def calculate_ndcg_top_n(user, recommendations, matrix, top_n=10):
    actual_ratings = matrix.loc[user]  # Rating sebenarnya
    pred_ratings = recommendations[user]  # Rating prediksi

    # Urutkan berdasarkan prediksi (ambil top-n)
    sorted_pred = sorted(pred_ratings.items(), key=lambda x: x[1], reverse=True)[:top_n]
    sorted_actual = sorted(actual_ratings.items(), key=lambda x: x[1], reverse=True)[:top_n]

    # DCG untuk top-n
    dcg = 0
    for i, (film, pred) in enumerate(sorted_pred):
        relevance = actual_ratings.get(film, 0)
        dcg += relevance / np.log2(i + 2)  # log2(i + 1) + 1 to avoid division by zero

    # IDCG (ideal DCG) untuk top-n
    idcg = 0
    for i, (film, actual) in enumerate(sorted_actual):
        relevance = actual_ratings.get(film, 0)
        idcg += relevance / np.log2(i + 2)

    ndcg = dcg / idcg if idcg > 0 else 0
    return ndcg

"""Memperoleh semua rekomendasi"""

# Menghitung rekomendasi untuk semua pengguna
all_recommendations = predict_ratings_all_users(matrix, user_similarity_df)

"""Menghitung NDCG"""

# Menghitung NDCG@top_n untuk semua pengguna
top_n = 10
ndcg_scores_top_n = {}
for user in matrix.index:
    ndcg_scores_top_n[user] = calculate_ndcg_top_n(user, all_recommendations, matrix, top_n=top_n)

# Menyimpan hasil rekomendasi dan NDCG@top_n ke file .npy
np.save("recommendations_tanpa_svd.npy", all_recommendations)
np.save("ndcg_scores_tanpa_svd.npy", ndcg_scores_top_n)

"""## Evaluasi dan Visualisasi

Menampilkan hasil perbandingan NDCG dengan menggunakan SVD dan tanpa menggunakan SVD
"""

import matplotlib.pyplot as plt
import numpy as np

# Load NDCG scores
ndcg_scores = np.load('ndcg_scores.npy', allow_pickle=True).item()
ndcg_scores_top_n = np.load('ndcg_scores_tanpa_svd.npy', allow_pickle=True).item()

# Extract NDCG values
ndcg_values = list(ndcg_scores.values())
ndcg_top_n_values = list(ndcg_scores_top_n.values())

# Create the plot
plt.figure(figsize=(10, 6))
plt.plot(range(len(ndcg_values)), ndcg_values, label='Dengan SVD')
plt.plot(range(len(ndcg_top_n_values)), ndcg_top_n_values, label='Tanpa SVD')
plt.xlabel('User')
plt.ylabel('NDCG')
plt.title('Perbandingan NDCG dengan dan tanpa SVD')
plt.legend()
plt.grid(True)
plt.show()

"""## Inference

Membuat dataframe list film
"""

df_list_film = pd.read_csv(file_path_list_film)

"""menampilkan list film"""

df_list_film

"""Membandingkan perbandingan hasil rekomendasi dari yang menggunakan SVD dan tanpa menggunakan SVD"""

# Memuat data yang diperlukan
recommendations = np.load('recommendations.npy', allow_pickle=True).item()  # Memuat rekomendasi dengan SVD
all_recommendations = np.load('recommendations_tanpa_svd.npy', allow_pickle=True).item()  # Memuat rekomendasi tanpa SVD
matrix = pd.read_csv(file_path_list_rating).pivot_table(index='User_ID', columns='Movie_ID', values='Rating', fill_value=0)  # Membuat matriks user-item
movies = pd.read_csv(file_path_list_film)  # Memuat daftar film

# Fungsi untuk mendapatkan judul film berdasarkan ID film
def get_movie_titles(movie_ids, movies_df):
    return movies_df[movies_df['Movie_ID'].isin(movie_ids)]['Name'].tolist()

# Input User ID
user_id_input = 1333  # ID pengguna yang ingin dicek rekomendasinya

# Mencari indeks pengguna pada matriks
try:
    user_index = matrix.index.get_loc(user_id_input)  # Mendapatkan indeks pengguna dari User_ID
except KeyError:
    print(f"User ID {user_id_input} tidak ditemukan.")  # Pesan jika User_ID tidak ditemukan
    exit()

# Mendapatkan rekomendasi untuk pengguna yang ditentukan (dengan dan tanpa SVD)
top_n = 10  # Jumlah rekomendasi teratas yang diinginkan

# Rekomendasi dengan SVD
if user_index in recommendations:
    recommended_items_svd = recommendations[user_index]['recommended_items']  # Film yang direkomendasikan
    movie_titles_svd = get_movie_titles(recommended_items_svd, movies)  # Mendapatkan judul film dari ID
    print(f"\nRekomendasi dengan SVD untuk User ID {user_id_input}:")
    for i, title in enumerate(movie_titles_svd):
        print(f"{i + 1}. {title}")  # Menampilkan rekomendasi satu per satu
else:
    print(f"Tidak ada rekomendasi yang ditemukan untuk User ID {user_id_input} dengan SVD.")

# Rekomendasi tanpa SVD
if user_id_input in all_recommendations:
    # Mengurutkan rekomendasi berdasarkan rating prediksi (top-N)
    recommended_items_no_svd = sorted(all_recommendations[user_id_input].items(), key=lambda x: x[1], reverse=True)[:top_n]
    movie_ids_no_svd = [movie_id for movie_id, _ in recommended_items_no_svd]  # Mengambil ID film
    movie_titles_no_svd = get_movie_titles(movie_ids_no_svd, movies)  # Mendapatkan judul film dari ID

    print(f"\nRekomendasi tanpa SVD untuk User ID {user_id_input}:")
    for i, title in enumerate(movie_titles_no_svd):
        print(f"{i + 1}. {title}")  # Menampilkan rekomendasi satu per satu
else:
    print(f"Tidak ada rekomendasi yang ditemukan untuk User ID {user_id_input} tanpa SVD.")